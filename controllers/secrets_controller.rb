###############################################################################
#
# thesplit - An API server to support the secure sharing of secrets.
# Copyright (c) 2016  Glenn Rempe
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

class SecretsController < ApplicationController
  post '/' do
    Stats.store('views/api/v1/secrets', count: 1, post: 1)

    # ID is 16 byte hash of the data that was stored
    param :id, String, required: true, min_length: 32, max_length: 32,
                       format: settings.hex_regex

    param :boxNonceB64, String, required: true, min_length: 24, max_length: 64,
                                format: settings.base64_regex

    param :boxB64, String, required: true, min_length: 1,
                           max_length: settings.secrets_max_length,
                           format: settings.base64_regex

    param :scryptSaltB64, String, required: true, min_length: 24, max_length: 64,
                                  format: settings.base64_regex

    # Differentiate between the client_hash_id and the server_hash_id.
    # The client hash is the hash of the contents generated by the client
    # and used as the client ID for requesting a secret.
    #
    # The server_hash_id is just the SHA256(client_hash_id) and is what is
    # used on the server side to store and find secrets.
    #
    # This simple step is taken help prevent reversing of the server storeage
    # key back to its original client ID. This prevents an attacker who gains
    # control of a DB dump from being able to search for that ID globally
    # (e.g. searching all email, or all Twitter, etc.) in order to
    # learn something about who has held that key ID. A small step
    # towards protecting the anonymity of the creator.
    #
    client_hash_id = params['id']
    server_hash_id = Digest::SHA256.hexdigest(client_hash_id)
    vault_index_key = "secret/#{server_hash_id}"

    scrypt_salt_b64 = params['scryptSaltB64']
    box_nonce_b64 = params['boxNonceB64']
    box_b64 = params['boxB64']

    t     = Time.now
    t_exp = t + settings.secrets_expire_in

    obj = { boxNonceB64: box_nonce_b64,
            boxB64: box_b64,
            scryptSaltB64: scrypt_salt_b64 }

    if Vault.logical.read(vault_index_key).present?
      halt 409, error_json('Data conflict, secret with ID already exists', 409)
    end

    one_time_token = vault_token_24h_1x

    # store the value of the one time token in a place we can find it
    Vault.logical.write(vault_index_key, token: one_time_token)

    # Store secret data using the one-time-use token
    # Instantiate a new Vault::Client in order to auth with the one-time token
    vc = Vault::Client.new
    # token num_uses - 1
    vc.auth.token(one_time_token)
    # token num_uses - 1
    vc.logical.write("cubbyhole/#{server_hash_id}", obj)

    # Send the hash to the blockchain. It will be passed through
    # SHA256 one more time before anchoring on the BTC blockchain.
    BlockchainSendHashWorker.perform_async(server_hash_id)

    return success_json(id: client_hash_id, createdAt: t.utc.iso8601,
                        expiresAt: t_exp.utc.iso8601)
  end

  options '/' do
    response.headers['Allow'] = 'POST'
    200
  end

  delete '/:id' do
    Stats.store('views/api/v1/secrets/id', count: 1)

    # ID is 16 byte hash of the data that was stored
    param :id, String, required: true, min_length: 32, max_length: 32,
                       format: settings.hex_regex

    client_hash_id = params['id']
    server_hash_id = Digest::SHA256.hexdigest(client_hash_id)
    vault_index_key = "secret/#{server_hash_id}"

    # find and revoke the token, which will also destroy any cubbyhole data
    vault_token = Vault.logical.read(vault_index_key)

    raise Sinatra::NotFound if vault_token.blank? || vault_token.data.blank?

    vc = Vault::Client.new
    # token num_uses - 1
    vc.auth.token(vault_token.data[:token])
    # token num_uses - 1
    # revocation of token also destroys any cubbyhole secrets
    vc.auth_token.revoke_self

    # deleting the index that let us find the token
    Vault.logical.delete(vault_index_key)

    return success_json
  end

  get '/:id' do
    Stats.store('views/api/v1/secrets/id', count: 1)

    # ID is the 16 byte hash of the data that was stored
    param :id, String, required: true, min_length: 32, max_length: 32,
                       format: settings.hex_regex

    client_hash_id = params['id']
    server_hash_id = Digest::SHA256.hexdigest(client_hash_id)

    vault_secret = nil
    vault_index_key = "secret/#{server_hash_id}"

    # Retrive the one-time use token using the app token
    vault_token = Vault.logical.read(vault_index_key)

    raise Sinatra::NotFound if vault_token.blank? || vault_token.data.blank?

    # Instantiate a new Vault::Client in order to auth with the one-time token
    vc = Vault::Client.new
    # token num_uses - 1
    vc.auth.token(vault_token.data[:token])
    # token num_uses - 1
    # one-time token private cubbyhole
    vault_secret = vc.logical.read("cubbyhole/#{server_hash_id}")

    # cleanup the index with the cubbyhole token
    Vault.logical.delete(vault_index_key)

    raise Sinatra::NotFound if vault_secret.blank? || vault_secret.data.blank?

    return success_json(vault_secret.data)
  end

  options '/:id' do
    response.headers['Allow'] = 'GET,DELETE'
    200
  end

  get '/:id/receipt' do
    Stats.store('views/api/v1/secrets/id/validate', count: 1)

    # ID is the 16 byte hash of the data that was stored
    param :id, String, required: true, min_length: 32, max_length: 32,
                       format: settings.hex_regex

    client_hash_id = params['id']
    server_hash_id = Digest::SHA256.hexdigest(client_hash_id)

    r = $redis.hget("blockchain:id:#{server_hash_id}", 'receipt')
    raise Sinatra::NotFound if r.blank?
    confirmed_at = $redis.hget("blockchain:id:#{server_hash_id}", 'confirmed')

    begin
      receipt_json = JSON.parse(r)
    rescue StandardError
      halt 500, error_json('server receipt could not be parsed', 500)
    end

    receipt = Tierion::HashApi::Receipt.new(receipt_json)

    unless receipt && receipt.valid?
      halt 500, error_json('server receipt is invalid', 500)
    end

    obj = {}
    obj[:receipt] = receipt
    obj[:confirmed_at] = confirmed_at.present? ? confirmed_at : nil

    return success_json(obj)
  end

  options '/:id/receipt' do
    response.headers['Allow'] = 'GET'
    200
  end

  def vault_token_24h_1x
    # num_uses is 4 since we auth, write, auth, read|delete in normal flow
    opts = { renewable: false,
             ttl: "#{settings.secrets_expire_in}s",
             explicit_max_ttl: "#{settings.secrets_expire_in}s",
             num_uses: 4,
             policies: ['default'] }

    Vault.with_retries(Vault::HTTPError, attempts: 3) do
      t = Vault.auth_token.create(opts)
      return t.auth.client_token
    end
  end
end
